# Story 08.001: File Prefix Placeholder Support

## User Story
As a **template user**,
I want **to specify a file prefix that gets automatically applied to all generated files**,
So that **I can organize outputs with consistent naming conventions without manual renaming**.

## Context
Users need the ability to add a consistent prefix to all generated document files (not folders) to organize outputs by project, date, or other categorization schemes. The `{{SOUBOR_PREFIX}}` placeholder should be automatically handled by the CLI infrastructure and always appear first in placeholder lists.

## Acceptance Criteria
1. `{{SOUBOR_PREFIX}}` placeholder is automatically recognized as a special system placeholder
2. The placeholder always appears first in scan results and placeholder input prompts
3. The CLI automatically applies the prefix value to generated file names (folders remain unchanged)
4. The placeholder is automatically handled during replacement operations
5. Empty or null prefix values are handled gracefully (no prefix applied)
6. File name conflicts are handled appropriately when prefixes are applied
7. The prefix is applied before file extension (e.g., "PREFIX_filename.docx")

## Technical Approach
### Core Changes
- Extend `Placeholder` model to support system placeholder classification
- Modify `IPlaceholderScanService` to identify and prioritize `{{SOUBOR_PREFIX}}`
- Enhance `IPlaceholderReplaceService` to handle file renaming during replacement

### CLI Integration
- Update scan command to list `{{SOUBOR_PREFIX}}` first in all output formats
- Modify replace command to automatically handle file prefixing
- Ensure JSON output maintains the special placeholder ordering

### File Processing
- Implement file renaming logic in `PlaceholderReplaceService`
- Handle edge cases: special characters, path length limits, existing files
- Preserve original file structure while applying prefixes only to files

## Implementation Details
```csharp
// New properties in Placeholder model
public bool IsSystemPlaceholder { get; set; }
public int SortOrder { get; set; } // -1 for SOUBOR_PREFIX to ensure first position

// New method in IPlaceholderReplaceService
Task<RenameResult> ApplyFilePrefixAsync(
    string targetDirectory, 
    string prefix, 
    CancellationToken cancellationToken = default);
```

## Examples
### Input Template Structure
```
templates/
├── document1.docx (contains {{SOUBOR_PREFIX}}, {{PROJECT_NAME}})
├── subfolder/
│   └── document2.docx (contains {{SOUBOR_PREFIX}}, {{DATE}})
```

### After Processing with prefix "ABC_"
```
output/
├── ABC_document1.docx
├── subfolder/
│   └── ABC_document2.docx
```

### Scan Output (JSON)
```json
{
  "placeholders": [
    {
      "name": "SOUBOR_PREFIX",
      "isSystemPlaceholder": true,
      "sortOrder": -1,
      "locations": [...]
    },
    {
      "name": "PROJECT_NAME",
      "isSystemPlaceholder": false,
      "sortOrder": 0,
      "locations": [...]
    }
  ]
}
```

## Edge Cases
1. **Empty prefix**: No renaming occurs, normal processing continues
2. **Special characters**: Sanitize prefix for file system compatibility
3. **Name conflicts**: Append numeric suffix (e.g., "PREFIX_file(1).docx")
4. **Long paths**: Truncate prefix if total path exceeds system limits
5. **Read-only files**: Handle permissions gracefully with clear error messages

## Definition of Done
- [ ] `{{SOUBOR_PREFIX}}` is recognized as special system placeholder
- [ ] Placeholder always appears first in scan results
- [ ] CLI automatically applies prefix to generated file names only
- [ ] Folders remain unchanged during processing
- [ ] File name conflicts are resolved automatically
- [ ] All output formats (text, JSON) respect placeholder ordering
- [ ] Comprehensive tests cover edge cases and error scenarios
- [ ] Documentation updated with prefix placeholder usage examples
- [ ] Backward compatibility maintained for existing functionality

## Testing Strategy
1. **Unit Tests**: Placeholder identification, sorting, and file renaming logic
2. **Integration Tests**: End-to-end workflow with various prefix values
3. **Edge Case Tests**: Empty values, special characters, conflicts, permissions
4. **Performance Tests**: Impact on processing time with large file sets
5. **CLI Tests**: Command behavior and output formatting validation