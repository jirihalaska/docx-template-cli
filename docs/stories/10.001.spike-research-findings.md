# Research Spike: Image Placeholder Implementation - Findings

## Executive Summary
After researching image placeholder functionality for DOCX templates, I recommend implementing a solution using **DocumentFormat.OpenXml** with **SkiaSharp** for image processing, using a hybrid approach of text placeholders with image parameters and optional Picture Content Controls for advanced scenarios.

## 1. DocumentFormat.OpenXml Image Insertion

### Key Findings
- **EMU Units**: OpenXML uses English Metric Units (EMUs) for dimensions
  - 1 inch = 914,400 EMUs
  - 1 cm = 360,000 EMUs  
  - 1 pixel = 9,525 EMUs (approximation)

### Implementation Approaches

#### Approach 1: Text Placeholder Replacement (Recommended)
- **Pros**: 
  - Seamless integration with existing placeholder system
  - Simple for users to create templates
  - No special Word features required
- **Cons**: 
  - Text must be in single run for replacement
  - No visual preview in template

#### Approach 2: Picture Content Controls
- **Pros**:
  - Visual placeholder in template
  - Size constraints built into control
  - Professional appearance
- **Cons**:
  - Requires users to insert content controls in Word
  - More complex template creation
  - Potential issue with shared embed IDs

#### Approach 3: Shape Containers
- **Pros**:
  - Fixed dimensions as boundaries
  - Can contain multiple elements
- **Cons**:
  - Complex implementation
  - Less intuitive for users

### Technical Implementation (POC Created)
```csharp
// Key components for image insertion:
1. Add ImagePart to MainDocumentPart
2. Feed image data to ImagePart
3. Create Drawing element with proper dimensions
4. Insert Drawing into document structure
5. Update both Inline.Extent and Transform2D.Extents
```

## 2. Image Processing Library Evaluation

### SkiaSharp (Recommended)
**Pros:**
- Free for commercial use
- Excellent performance (low memory usage)
- Hardware acceleration support
- Maintained by Microsoft (Xamarin team)
- Cross-platform: Windows, macOS, Linux

**Cons:**
- Native dependencies (adds ~10-15MB to deployment)
- More complex API
- Primarily a rendering library

### ImageSharp
**Pros:**
- Pure managed code (no native dependencies)
- Intuitive fluent API
- Comprehensive image processing features
- Easy deployment

**Cons:**
- Requires commercial license ($299/year)
- Higher memory usage
- Slightly slower than SkiaSharp

### Recommendation: SkiaSharp
- Free licensing aligns with open-source project
- Performance benefits outweigh deployment complexity
- Native dependencies acceptable for self-contained deployment

## 3. Placeholder Syntax Design

### Proposed Syntax
```
{{image:placeholder_name|width:200|height:150|fit:contain}}
```

### Parameters:
- `image:` - Identifies this as an image placeholder
- `placeholder_name` - Unique identifier for the image
- `width:` - Maximum width in pixels
- `height:` - Maximum height in pixels  
- `fit:` - Resize mode (optional)
  - `contain` - Fit within bounds, preserve aspect ratio (default)
  - `cover` - Fill bounds, crop if necessary
  - `stretch` - Ignore aspect ratio, fill exact dimensions

### Examples:
```
{{image:company_logo|width:200|height:80}}
{{image:product_photo|width:400|height:300|fit:cover}}
{{image:signature|width:150|height:50|fit:contain}}
```

### Backwards Compatibility:
- Existing text placeholders continue to work unchanged
- Image placeholders use extended syntax with `image:` prefix
- Scanner can differentiate based on prefix

## 4. Architecture Design

### Domain Model Extensions
```csharp
public enum PlaceholderType
{
    Text,
    Image
}

public record ImagePlaceholderMetadata
{
    public int MaxWidth { get; init; }
    public int MaxHeight { get; init; }
    public ImageFitMode FitMode { get; init; }
}
```

### Service Interface Updates
```csharp
public interface IPlaceholderReplaceService
{
    // Existing method handles both text and images
    Task<ReplaceResult> ReplacePlaceholdersAsync(
        IReadOnlyList<TemplateFile> templateFiles,
        ReplacementMap replacementMap,
        bool createBackup = true,
        CancellationToken cancellationToken = default);
}
```

### UI Integration
- Add file picker to `PlaceholderValueViewModel`
- Detect image placeholders and show file selector
- Store file paths in JSON mapping
- Optional: Image preview in UI

## 5. Implementation Plan

### Phase 1: Core Implementation (4 hours)
1. Add SkiaSharp NuGet package
2. Extend Placeholder model for image metadata
3. Update PlaceholderScanService to detect image syntax
4. Implement image insertion in PlaceholderReplaceService
5. Add image resizing logic with SkiaSharp

### Phase 2: UI Integration (2 hours)
1. Update PlaceholderValueViewModel for file selection
2. Add Avalonia file picker for images
3. Update value entry dialog UI
4. Add validation for image files

### Phase 3: Testing & Documentation (2 hours)
1. Unit tests for image placeholder detection
2. Unit tests for image resizing logic
3. Integration tests for end-to-end replacement
4. Update user documentation

## 6. Risk Assessment

### Technical Risks
- **Image Format Compatibility**: Mitigated by SkiaSharp's broad format support
- **Memory Usage with Large Images**: Implement size limits and streaming
- **Cross-platform File Paths**: Use Path.Combine consistently

### User Experience Risks
- **Complex Syntax**: Provide clear documentation and examples
- **Template Creation**: Consider helper tool for inserting placeholders

## 7. Alternative Considerations

### Base64 Encoding in JSON
- **Pros**: Self-contained mapping files
- **Cons**: Large JSON files, memory overhead
- **Decision**: Use file paths, consider base64 as future option

### Multiple Image Insertion Methods
- Support both text placeholders and content controls
- Let users choose based on their needs
- Start with text placeholders, add content controls later

## 8. Recommendations

### Immediate Actions
1. **Proceed with SkiaSharp** for image processing
2. **Implement text placeholder approach** first
3. **Use proposed syntax** with image: prefix
4. **Create comprehensive unit tests** for image handling

### Future Enhancements
1. Picture Content Control support
2. Image caching for repeated use
3. Additional fit modes (crop positions)
4. SVG support
5. Image optimization/compression

## 9. Code Samples

### Detecting Image Placeholders
```csharp
private static readonly Regex ImagePlaceholderPattern = 
    new(@"\{\{image:([^|]+)\|width:(\d+)\|height:(\d+)(?:\|fit:(\w+))?\}\}", 
        RegexOptions.Compiled);
```

### Processing Image with SkiaSharp
```csharp
using (var bitmap = SKBitmap.Decode(imagePath))
{
    var resized = bitmap.Resize(
        new SKImageInfo(targetWidth, targetHeight), 
        SKFilterQuality.High);
    
    using (var image = SKImage.FromBitmap(resized))
    using (var data = image.Encode(SKEncodedImageFormat.Jpeg, 90))
    {
        return data.ToArray();
    }
}
```

## Conclusion
The research confirms that implementing image placeholders is technically feasible and can be integrated smoothly with the existing architecture. The recommended approach using text placeholders with SkiaSharp provides the best balance of functionality, performance, and user experience while maintaining backwards compatibility.

## Next Steps
1. Review and approve technical approach
2. Update implementation story with specific details
3. Begin Phase 1 implementation
4. Create test templates with image placeholders