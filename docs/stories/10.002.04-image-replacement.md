# Task 10.002.04: Image Replacement Logic in DOCX

## Task Overview
Implement the core logic to replace image placeholders with actual images in DOCX documents using OpenXML.

## Prerequisites
- Tasks 10.002.01-03 completed
- Understanding of OpenXML Drawing namespace
- Image processing infrastructure ready

## Implementation Steps

### 1. Extend PlaceholderReplaceService
**File:** `src/DocxTemplate.Infrastructure/DocxProcessing/PlaceholderReplaceService.cs`

Add image replacement capability to existing service:
```csharp
private async Task<bool> ReplaceImagePlaceholder(
    WordprocessingDocument doc,
    Placeholder placeholder,
    string imagePath)
{
    // Implementation here
}
```

### 2. Implement Image Insertion Logic
**CRITICAL:** Preserve original image quality, only set display dimensions

```csharp
private void InsertImage(Run run, string imagePath, long widthEmus, long heightEmus)
{
    // Load image WITHOUT resizing - preserve quality
    var imageBytes = File.ReadAllBytes(imagePath);
    var imagePartType = GetImagePartType(imagePath);
    
    // Get main document part
    var mainPart = run.Ancestors<Document>().First()
        .MainDocumentPart;
    
    // Add image part to document
    var imagePart = mainPart.AddImagePart(imagePartType);
    using (var stream = new MemoryStream(imageBytes))
    {
        imagePart.FeedData(stream);
    }
    
    // Get relationship ID
    var relationshipId = mainPart.GetIdOfPart(imagePart);
    
    // Create and append Drawing element
    var drawing = CreateImageElement(relationshipId, widthEmus, heightEmus);
    run.AppendChild(drawing);
}
```

### 3. Create OpenXML Drawing Element
**File:** `src/DocxTemplate.Infrastructure/DocxProcessing/DrawingElementFactory.cs`

```csharp
private static Drawing CreateImageElement(string relationshipId, long widthEmus, long heightEmus)
{
    return new Drawing(
        new DW.Inline(
            new DW.Extent() { Cx = widthEmus, Cy = heightEmus },
            new DW.EffectExtent() { LeftEdge = 0L, TopEdge = 0L, RightEdge = 0L, BottomEdge = 0L },
            new DW.DocProperties() { Id = GenerateDocPropertyId(), Name = "Picture" },
            new DW.NonVisualGraphicFrameDrawingProperties(
                new A.GraphicFrameLocks() { NoChangeAspect = true }),
            new A.Graphic(
                new A.GraphicData(
                    new PIC.Picture(
                        // Picture properties...
                    )
                ) { Uri = "http://schemas.openxmlformats.org/drawingml/2006/picture" }
            )
        )
    );
}
```

### 4. Handle Placeholder Removal and Replacement
```csharp
private void ReplaceTextWithImage(Paragraph paragraph, Placeholder placeholder, Drawing imageDrawing)
{
    // Find runs containing the placeholder
    var runs = FindPlaceholderRuns(paragraph, placeholder);
    
    // Clear text from runs
    ClearRunsText(runs);
    
    // Insert image in first run
    runs.First().AppendChild(imageDrawing);
}
```

### 5. Implement Fallback for Failed Images
```csharp
private void InsertFallbackText(Run run, string placeholderName, string error)
{
    run.AppendChild(new Text($"[Image '{placeholderName}' failed: {error}]"));
}
```

## Error Handling
- Image file not found
- Invalid image format
- Insufficient permissions
- Corrupted DOCX structure
- Memory constraints

## Integration Points
- Coordinate with PlaceholderScanner for location info
- Use ImageProcessor for dimension calculations
- Integrate with existing replacement pipeline

## Unit Tests Required
- Test image insertion into simple document
- Test replacement in complex documents (tables, headers)
- Test multiple image replacements
- Test fallback for missing images
- Test preservation of image quality

## Success Criteria
- [ ] Images inserted at correct placeholder locations
- [ ] Original image quality preserved
- [ ] Display dimensions correctly applied
- [ ] Aspect ratio maintained
- [ ] Fallback text for failed images
- [ ] No corruption of DOCX structure

## Estimated Time: 2.5 hours