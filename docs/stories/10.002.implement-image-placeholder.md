# Story 2: Implementation - Image Placeholder Support

## Story Title
**Implement Image Placeholder with Auto-Resize** - Feature Addition

## User Story
As a **template user**,  
I want **to use image placeholders that get replaced with resized images**,  
So that **I can create documents with properly formatted images**.

## Prerequisites
- [ ] Research spike (001) completed
- [ ] Technical approach approved
- [ ] Required libraries identified
- [ ] Placeholder syntax finalized

## Story Context

### Existing System Integration
- **Extends:** `IPlaceholderReplaceService` and `IPlaceholderScanService`
- **UI Integration:** `PlaceholderValueViewModel` for file selection
- **Follows:** Existing placeholder replacement patterns
- **Affects:** Core, Infrastructure, and UI layers

## Acceptance Criteria

### Functional Requirements
1. Image placeholders are detected during scan operation
2. UI provides file picker for image selection (PNG, JPEG, JPG, GIF, BMP)
3. Images are automatically resized to fit specified boundaries
4. Replaced images appear correctly in output document
5. Aspect ratio is maintained during resize

### Integration Requirements
6. Text placeholders continue working unchanged
7. JSON mapping supports image file paths
8. Error handling for missing/invalid images
9. GUI supports image placeholders with file picker

### Quality Requirements
10. Performance acceptable (<2s for typical image)
11. Memory usage reasonable (<100MB for operation)
12. Works on all supported platforms
13. No significant increase in deployment size

## Implementation Tasks

### Core Layer
- [ ] Add image placeholder type to domain model
- [ ] Extend `Placeholder` class for image-specific properties
- [ ] Update service interfaces for image support

### Infrastructure Layer
- [ ] Implement image detection in `PlaceholderScanService`
- [ ] Add image replacement logic to `PlaceholderReplaceService`
- [ ] Integrate chosen image processing library
- [ ] Implement image resizing logic

### UI Layer
- [ ] Add file picker to `PlaceholderValueViewModel`
- [ ] Update value entry dialog for image placeholders
- [ ] Add validation for image files

### Testing
- [ ] Unit tests for image placeholder detection
- [ ] Unit tests for image resizing logic
- [ ] Integration tests for end-to-end replacement
- [ ] Cross-platform testing

### Documentation
- [ ] Add image placeholder examples
- [ ] Document supported image formats
- [ ] Update user guide

## Technical Notes

### Finalized Approach from POC
- **Chosen image library:** SkiaSharp (cross-platform, free, MIT license)
- **Placeholder syntax:** `{{image:name|width:pixels|height:pixels}}`
- **Fit mode:** Always "contain" (preserve aspect ratio within bounds)
- **Image storage strategy:** File paths in JSON mapping

### Critical Implementation Details

#### 1. Image Quality Preservation
**CRITICAL:** Do NOT resize the actual image data. Preserve original quality by only setting display dimensions:

```csharp
// Load image WITHOUT resizing - keep original quality
var imageBytes = File.ReadAllBytes(imagePath);

// Get original image dimensions for aspect ratio calculation
var (originalWidth, originalHeight) = GetImageDimensions(imagePath);

// Calculate DISPLAY dimensions (not resize the image data)
// Always use "contain" mode to preserve aspect ratio
var (displayWidth, displayHeight) = CalculateDisplayDimensions(
    originalWidth, originalHeight, maxWidthPixels, maxHeightPixels);

// Convert pixels to EMUs for Word (1 pixel = 9525 EMUs)
long widthEmus = displayWidth * 9525L;
long heightEmus = displayHeight * 9525L;
```

#### 2. Image Insertion into DOCX
```csharp
private static void InsertImage(W.Run run, string imagePath, long widthEmus, long heightEmus)
{
    var imageBytes = File.ReadAllBytes(imagePath);
    var imagePartType = GetImagePartType(imagePath);
    
    // Get the main document part
    var mainPart = run.Ancestors<Document>().First()
        .MainDocumentPart;
    
    // Add image part to document
    var imagePart = mainPart.AddImagePart(imagePartType.ContentType);
    using (var stream = new MemoryStream(imageBytes))
    {
        imagePart.FeedData(stream);
    }
    
    // Add relationship and get ID
    var relationshipId = mainPart.GetIdOfPart(imagePart);
    
    // Create the Drawing element with the image
    var element = CreateImageElement(relationshipId, widthEmus, heightEmus);
    run.AppendChild(element);
}

private static Drawing CreateImageElement(string relationshipId, long widthEmus, long heightEmus)
{
    return new Drawing(
        new DW.Inline(
            new DW.Extent() { Cx = widthEmus, Cy = heightEmus },
            new DW.EffectExtent() { LeftEdge = 0L, TopEdge = 0L, RightEdge = 0L, BottomEdge = 0L },
            new DW.DocProperties() { Id = 1U, Name = "Picture" },
            new DW.NonVisualGraphicFrameDrawingProperties(
                new A.GraphicFrameLocks() { NoChangeAspect = true }),
            new A.Graphic(
                new A.GraphicData(
                    new PIC.Picture(
                        new PIC.NonVisualPictureProperties(
                            new PIC.NonVisualDrawingProperties() { Id = 0U, Name = "Image" },
                            new PIC.NonVisualPictureDrawingProperties()),
                        new PIC.BlipFill(
                            new A.Blip() { Embed = relationshipId },
                            new A.Stretch(new A.FillRectangle())),
                        new PIC.ShapeProperties(
                            new A.Transform2D(
                                new A.Offset() { X = 0L, Y = 0L },
                                new A.Extents() { Cx = widthEmus, Cy = heightEmus }),
                            new A.PresetGeometry(new A.AdjustValueList()) { Preset = A.ShapeTypeValues.Rectangle }
                        )
                    )
                ) { Uri = "http://schemas.openxmlformats.org/drawingml/2006/picture" }
            )
        )
    );
}
```

#### 3. Placeholder Detection with Text Run Reconstruction
Word often splits placeholders across multiple text runs. Reconstruction is essential:

```csharp
var runs = paragraph.Descendants<W.Run>().ToList();
var fullText = string.Join("", runs.Select(r => r.InnerText));

// Check for image placeholder pattern
var match = Regex.Match(fullText, @"\{\{image:([^|]+)\|width:(\d+)\|height:(\d+)\}\}");
if (match.Success)
{
    var imageName = match.Groups[1].Value;
    var width = int.Parse(match.Groups[2].Value);
    var height = int.Parse(match.Groups[3].Value);
    
    // Process the placeholder...
}
```

#### 4. Aspect Ratio Calculation
```csharp
private static (int width, int height) CalculateDisplayDimensions(
    int originalWidth, int originalHeight, int maxWidth, int maxHeight)
{
    // Always use "contain" mode - scale to fit within bounds, preserving aspect ratio
    double scaleWidth = (double)maxWidth / originalWidth;
    double scaleHeight = (double)maxHeight / originalHeight;
    double scale = Math.Min(scaleWidth, scaleHeight);
    
    return ((int)(originalWidth * scale), (int)(originalHeight * scale));
}
```

### Key Constants
```csharp
private const int EmusPerPixel = 9525;  // English Metric Units conversion
```

## Definition of Done
- [ ] Feature implemented per research findings
- [ ] All unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed on Windows, macOS, Linux
- [ ] Documentation updated
- [ ] Code reviewed and approved
- [ ] No regression in existing functionality

## Risk Mitigation
- Fallback to placeholder text if image fails to load
- Clear error messages for invalid images
- Size limits for image files to prevent memory issues
- Validation of image formats before processing

## Estimated Effort
**6 hours** (adjust based on research findings)

## Dependencies
- Research spike findings
- Chosen image processing library
- Updated DocumentFormat.OpenXml if needed

## Notes
- Consider adding image caching for repeated use
- Future enhancement: image cropping/positioning options
- Consider supporting SVG in future iteration